{"version":3,"file":"boobreaks.common.js","sources":["../src/index.ts"],"sourcesContent":["import './style.scss'\n\nexport type XS = 'xs'\nexport type SM = 'sm'\nexport type MD = 'md'\nexport type LG = 'lg'\nexport type XL = 'xl'\nexport type ALIAS = XS | SM | MD | LG | XL\nexport type UN = 'unrecognized'\n\nexport interface IBoobreaksVars {\n  breakpoints: string[]\n  widths: (number | null)[]\n}\n\nexport default class Boobreaks {\n  /**\n   * Default bootstrap values.\n   *\n   * @see https://github.com/twbs/bootstrap/blob/master/scss/_variables.scss#L191-L197\n   */\n  private vars: IBoobreaksVars = {\n    breakpoints: ['xs', 'sm', 'md', 'lg', 'xl'],\n    widths: [null, 576, 768, 992, 1200],\n  }\n\n  constructor(vars: IBoobreaksVars) {\n    this.vars = { ...this.vars, ...vars }\n  }\n\n  /**\n   * Returns current breakpoint alias.\n   */\n  current(): ALIAS | UN {\n    const body = document.querySelector('body')\n    if (!body) throw new Error('No `body` found!')\n    return <ALIAS>window\n        .getComputedStyle(body, ':before')\n        .getPropertyValue('content')\n        .replace(/\"/g, '') || 'unrecognized'\n  }\n\n  /**\n   * Returns current breakpoint size.\n   */\n  width(): number | null {\n    return this.vars.widths[\n      this.vars.breakpoints.indexOf(this.current().toLowerCase())\n    ]\n  }\n\n  /**\n   * Returns true if current breakpoint matches passed glob.\n   */\n  is(str: string): boolean {\n    if (this.isAnExpression(str)) {\n      return this.isMatchingExpression(str) || false\n    }\n\n    return this.current() === str\n  }\n\n  /**\n   * Determines whether passed string is a parsable expression\n   */\n  private isAnExpression(str: string): boolean {\n    return str.charAt(0) === '<' || str.charAt(0) === '>'\n  }\n\n  /**\n   * Splits the expression into <,> and = alias\n   */\n  private splitExpression(str: string) {\n    // Used operator\n    const operator = str.charAt(0)\n    // Includes breakpoint equal to alias?\n    const orEqual = str.charAt(1) === '='\n\n    /**\n     * Index at which the breakpoint name starts.\n     *\n     * For:  >sm, index = 1\n     * For: >=sm, index = 2\n     */\n    const index = 1 + (orEqual ? 1 : 0)\n\n    /**\n     * The remaining part of the expression, after the operator, will be treated as the\n     * breakpoint name to compare with\n     */\n    const breakpointName = str.slice(index)\n\n    return {\n      operator,\n      orEqual,\n      breakpointName,\n    }\n  }\n\n  /**\n   * Determines whether current breakpoint matches the expression given\n   */\n  private isMatchingExpression(str: string): boolean | undefined {\n    const expression = this.splitExpression(str)\n\n    // Cache breakpoint names\n    const breakpointList = this.vars.breakpoints\n\n    // Get index of sought breakpoint in the list\n    let pos = breakpointList.indexOf(expression.breakpointName)\n\n    // Breakpoint found\n    if (pos !== -1) {\n      let start: number | undefined = 0\n      let end: number | undefined = 0\n\n      /**\n       * Parsing viewport.is('<=md') we interate from smallest breakpoint ('xs') and end\n       * at 'md' breakpoint, indicated in the expression,\n       * That makes: start = 0, end = 2 (index of 'md' breakpoint)\n       *\n       * Parsing viewport.is('<md') we start at index 'xs' breakpoint, and end at\n       * 'sm' breakpoint, one before 'md'.\n       * Which makes: start = 0, end = 1\n       */\n      if (expression.operator === '<') {\n        start = 0\n        end = expression.orEqual ? ++pos : pos\n      }\n      /**\n       * Parsing viewport.is('>=sm') we interate from breakpoint 'sm' and end at the end\n       * of breakpoint list.\n       * That makes: start = 1, end = undefined\n       *\n       * Parsing viewport.is('>sm') we start at breakpoint 'md' and end at the end of\n       * breakpoint list.\n       * Which makes: start = 2, end = undefined\n       */\n      if (expression.operator === '>') {\n        start = expression.orEqual ? pos : ++pos\n        end = undefined\n      }\n\n      const acceptedBreakpoints = breakpointList.slice(start, end)\n\n      return acceptedBreakpoints.includes(this.current())\n    }\n\n    return undefined\n  }\n}\n"],"names":["Boobreaks","[object Object]","vars","this","breakpoints","widths","body","document","querySelector","Error","window","getComputedStyle","getPropertyValue","replace","indexOf","current","toLowerCase","str","isAnExpression","isMatchingExpression","charAt","operator","orEqual","index","breakpointName","slice","expression","splitExpression","breakpointList","pos","start","end","undefined","includes"],"mappings":";;;;;;;;;mBAeqBA,UAWnBC,YAAYC,GALJC,UAAuB,CAC7BC,YAAa,CAAC,KAAM,KAAM,KAAM,KAAM,MACtCC,OAAQ,CAAC,KAAM,IAAK,IAAK,IAAK,OAI9BF,KAAKD,sBAAYC,KAAKD,KAASA,GAMjCD,UACE,MAAMK,EAAOC,SAASC,cAAc,QACpC,IAAKF,EAAM,MAAM,IAAIG,MAAM,oBAC3B,OAAcC,OACTC,iBAAiBL,EAAM,WACvBM,iBAAiB,WACjBC,QAAQ,KAAM,KAAO,eAM5BZ,QACE,OAAOE,KAAKD,KAAKG,OACfF,KAAKD,KAAKE,YAAYU,QAAQX,KAAKY,UAAUC,gBAOjDf,GAAGgB,GACD,OAAId,KAAKe,eAAeD,GACfd,KAAKgB,qBAAqBF,KAAQ,EAGpCd,KAAKY,YAAcE,EAMpBhB,eAAegB,GACrB,MAAyB,MAAlBA,EAAIG,OAAO,IAAgC,MAAlBH,EAAIG,OAAO,GAMrCnB,gBAAgBgB,GAEtB,MAAMI,EAAWJ,EAAIG,OAAO,GAEtBE,EAA4B,MAAlBL,EAAIG,OAAO,GAQrBG,EAAQ,GAAKD,EAAU,EAAI,GAQjC,MAAO,CACLD,SAAAA,EACAC,QAAAA,EACAE,eALqBP,EAAIQ,MAAMF,IAY3BtB,qBAAqBgB,GAC3B,MAAMS,EAAavB,KAAKwB,gBAAgBV,GAGlCW,EAAiBzB,KAAKD,KAAKE,YAGjC,IAAIyB,EAAMD,EAAed,QAAQY,EAAWF,gBAG5C,IAAa,IAATK,EAAY,CACd,IAAIC,EAA4B,EAC5BC,EAA0B,EA+B9B,MApB4B,MAAxBL,EAAWL,WACbS,EAAQ,EACRC,EAAML,EAAWJ,UAAYO,EAAMA,GAWT,MAAxBH,EAAWL,WACbS,EAAQJ,EAAWJ,QAAUO,IAAQA,EACrCE,OAAMC,GAGoBJ,EAAeH,MAAMK,EAAOC,GAE7BE,SAAS9B,KAAKY"}