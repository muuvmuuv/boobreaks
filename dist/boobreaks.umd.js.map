{"version":3,"file":"boobreaks.umd.js","sources":["../src/index.ts"],"sourcesContent":["import './style.scss'\n\nexport type Breakpoint = string\nexport type Width = number\n\nexport interface Vars {\n  breakpoints: Breakpoint[]\n  widths: Width[]\n}\n\n/**\n * Default bootstrap values.\n *\n * @see https://github.com/twbs/bootstrap/blob/master/scss/_variables.scss#L191-L197\n */\nconst vars: Vars = {\n  breakpoints: ['xs', 'sm', 'md', 'lg', 'xl'],\n  widths: [0, 576, 768, 992, 1200],\n}\n\n/**\n * The target element to optain the pseudo content value from.\n */\n// let __target: HTMLElement = <HTMLElement>document.querySelector('body')\n\n/**\n * Set the target.\n */\n// function target(element: string | HTMLElement) {\n//   let target\n//   if (typeof element === 'string') {\n//     target = <HTMLElement>document.querySelector(element)\n//   } else {\n//     target = element\n//   }\n//   if (!target) {\n//     return console.error('Unknown element', element)\n//   }\n//   __target = target\n// }\n\n/**\n * Returns current breakpoint alias.\n */\nfunction current(): Breakpoint | undefined {\n  const target = <HTMLElement>document.querySelector('body')\n  const content = window.getComputedStyle(target, ':before').getPropertyValue('content')\n  // if (content === 'none') {\n  //   console.error('No breakpoint value found for', target)\n  // }\n  return content.replace(/\"/g, '') || undefined\n}\n\n/**\n * Returns current breakpoint size.\n */\nfunction width(): Width | undefined {\n  const curr = current()\n  if (!curr) return undefined\n  return vars.widths[vars.breakpoints.indexOf(curr.toLowerCase())]\n}\n\n/**\n * Returns true if current breakpoint matches passed glob.\n */\nfunction is(str: string): boolean | undefined {\n  if (__isAnExpression(str)) {\n    return __isMatchingExpression(str)\n  }\n\n  return current() === str\n}\n\n/**\n * Determines whether passed string is a parsable expression.\n */\nfunction __isAnExpression(str: string): boolean {\n  return str.charAt(0) === '<' || str.charAt(0) === '>'\n}\n\n/**\n * Splits the expression into <,> and = alias.\n */\nfunction __splitExpression(str: string) {\n  const operator = str.charAt(0) // operator\n  const orEqual = str.charAt(1) === '=' // equal to\n\n  /**\n   * Index at which the breakpoint name starts.\n   *\n   * For:  >sm, index = 1\n   * For: >=sm, index = 2\n   */\n  const index = 1 + (orEqual ? 1 : 0)\n\n  /**\n   * The remaining part of the expression, after the operator, will be treated as the\n   * breakpoint name to compare with\n   */\n  const breakpointName = str.slice(index)\n\n  return {\n    operator,\n    orEqual,\n    breakpointName,\n  }\n}\n\n/**\n * Determines whether current breakpoint matches the expression given\n */\nfunction __isMatchingExpression(str: string): boolean | undefined {\n  const curr = current()\n  if (!curr) return undefined\n\n  const expression = __splitExpression(str)\n\n  let pos = vars.breakpoints.indexOf(expression.breakpointName)\n  if (pos == -1) return undefined\n\n  let start: number = 0\n  let end: number | undefined = undefined\n\n  /**\n   * Parsing viewport.is('<=md') we interate from smallest breakpoint ('xs') and end\n   * at 'md' breakpoint, indicated in the expression,\n   * That makes: start = 0, end = 2 (index of 'md' breakpoint)\n   *\n   * Parsing viewport.is('<md') we start at index 'xs' breakpoint, and end at\n   * 'sm' breakpoint, one before 'md'.\n   * Which makes: start = 0, end = 1\n   */\n  if (expression.operator === '<') {\n    end = expression.orEqual ? ++pos : pos\n  }\n\n  /**\n   * Parsing viewport.is('>=sm') we interate from breakpoint 'sm' and end at the end\n   * of breakpoint list.\n   * That makes: start = 1, end = undefined\n   *\n   * Parsing viewport.is('>sm') we start at breakpoint 'md' and end at the end of\n   * breakpoint list.\n   * Which makes: start = 2, end = undefined\n   */\n  if (expression.operator === '>') {\n    start = expression.orEqual ? pos : ++pos\n  }\n\n  const acceptedBreakpoints = vars.breakpoints.slice(start, end)\n\n  /**\n   * If there are no accepted breakpoints we are below `xs` or above `xl` and if\n   * it matches the current breakpoint its true.\n   */\n  if (acceptedBreakpoints.length === 0 && expression.breakpointName === current()) {\n    return true\n  }\n\n  return acceptedBreakpoints.includes(curr)\n}\n\nexport { vars, current, is, width }\n"],"names":["vars","breakpoints","widths","current","target","document","querySelector","window","getComputedStyle","getPropertyValue","replace","undefined","str","charAt","__isAnExpression","curr","expression","operator","orEqual","slice","__splitExpression","pos","indexOf","breakpointName","start","end","acceptedBreakpoints","length","includes","__isMatchingExpression","toLowerCase"],"mappings":"mLAeMA,EAAa,CACjBC,YAAa,CAAC,KAAM,KAAM,KAAM,KAAM,MACtCC,OAAQ,CAAC,EAAG,IAAK,IAAK,IAAK,OA2B7B,SAASC,QACDC,EAAsBC,SAASC,cAAc,eACnCC,OAAOC,iBAAiBJ,EAAQ,WAAWK,iBAAiB,WAI7DC,QAAQ,KAAM,UAAOC,4BAetC,SAAYC,UAWZ,SAA0BA,SACC,MAAlBA,EAAIC,OAAO,IAAgC,MAAlBD,EAAIC,OAAO,GAXvCC,CAAiBF,GA6CvB,SAAgCA,OACxBG,EAAOZ,OACRY,OAECC,EAhCR,SAA2BJ,OACnBK,EAAWL,EAAIC,OAAO,GACtBK,EAA4B,MAAlBN,EAAIC,OAAO,SAgBpB,UACLI,UACAC,iBAJqBN,EAAIO,MANb,GAAKD,EAAU,EAAI,KAsBdE,CAAkBR,GAEjCS,EAAMrB,EAAKC,YAAYqB,QAAQN,EAAWO,oBAClC,GAARF,OAEAG,EAAgB,EAChBC,OAA0Bd,EAWF,MAAxBK,EAAWC,WACbQ,EAAMT,EAAWE,UAAYG,EAAMA,GAYT,MAAxBL,EAAWC,WACbO,EAAQR,EAAWE,QAAUG,IAAQA,OAGjCK,EAAsB1B,EAAKC,YAAYkB,MAAMK,EAAOC,UAMvB,IAA/BC,EAAoBC,QAAgBX,EAAWO,iBAAmBpB,KAI/DuB,EAAoBE,SAASb,KA5F3Bc,CAAuBjB,GAGzBT,MAAcS,WAdvB,eACQG,EAAOZ,OACRY,SACEf,EAAKE,OAAOF,EAAKC,YAAYqB,QAAQP,EAAKe"}