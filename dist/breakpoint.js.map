{"version":3,"sources":["breakpoint.js"],"names":["Breakpoint","breakpoints","widths","current","window","getComputedStyle","document","querySelector","getPropertyValue","replace","width","indexOf","toLowerCase","is","str","_isAnExpression","_isMatchingExpression","charAt","_splitExpression","operator","orEqual","index","breakpointName","slice","_isAnyActive","find","alias","expression","breakpointList","pos","start","end","undefined","acceptedBreakpoints"],"mappings":"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","sourcesContent":["/**\n * Use Bootstrap breakpoints inside you JavaScript!\n *\n * Originally created by Maciej Gurban\n * https://github.com/maciej-gurban/responsive-bootstrap-toolkit\n *\n * @author Marvin Heilemann\n * @license MIT\n * @see https://getbootstrap.com/docs/4.3/layout/overview/#responsive-breakpoints\n */\n\nconst Breakpoint = {\n  breakpoints: ['xs', 'sm', 'md', 'lg', 'xl'],\n  widths: [null, 576, 768, 992, 1200],\n\n  /**\n   * Returns current breakpoint alias.\n   *\n   * @example Breakpoint.current()\n   * @return {string} xs|sm|md|lg|xl\n   */\n  current() {\n    return (\n      window\n        .getComputedStyle(document.querySelector('body'), ':before')\n        .getPropertyValue('content')\n        .replace(/\"/g, '') || 'unrecognized'\n    )\n  },\n\n  /**\n   * Returns current breakpoint size.\n   *\n   * @example Breakpoint.width()\n   * @return {boolean} null|576|768|992|1200\n   */\n  width() {\n    return this.widths[this.breakpoints.indexOf(this.current().toLowerCase())]\n  },\n\n  /**\n   * Returns true if current breakpoint matches passed glob.\n   *\n   * @example Breakpoint.is('<=md')\n   * @return {boolean} true|false\n   */\n  is(str) {\n    if (this._isAnExpression(str)) {\n      return this._isMatchingExpression(str)\n    }\n\n    return this.current() === str\n  },\n\n  /**\n   * Determines whether passed string is a parsable expression\n   */\n  _isAnExpression(str) {\n    return str.charAt(0) === '<' || str.charAt(0) === '>'\n  },\n\n  /**\n   * Splits the expression into <,> and = alias\n   */\n  _splitExpression(str) {\n    // Used operator\n    const operator = str.charAt(0)\n    // Includes breakpoint equal to alias?\n    const orEqual = str.charAt(1) === '='\n\n    /**\n     * Index at which the breakpoint name starts.\n     *\n     * For:  >sm, index = 1\n     * For: >=sm, index = 2\n     */\n    const index = 1 + (orEqual ? 1 : 0)\n\n    /**\n     * The remaining part of the expression, after the operator, will be treated as the\n     * breakpoint name to compare with\n     */\n    const breakpointName = str.slice(index)\n\n    return {\n      operator,\n      orEqual,\n      breakpointName,\n    }\n  },\n\n  /**\n   * Returns true if currently active breakpoint matches the expression\n   */\n  _isAnyActive(breakpoints) {\n    return breakpoints.find(alias => this.current() === alias)\n  },\n\n  /**\n   * Determines whether current breakpoint matches the expression given\n   */\n  _isMatchingExpression(str) {\n    const expression = this._splitExpression(str)\n\n    // Cache breakpoint names\n    const breakpointList = this.breakpoints\n\n    // Get index of sought breakpoint in the list\n    let pos = breakpointList.indexOf(expression.breakpointName)\n\n    // Breakpoint found\n    if (pos !== -1) {\n      let start = 0\n      let end = 0\n\n      /**\n       * Parsing viewport.is('<=md') we interate from smallest breakpoint ('xs') and end\n       * at 'md' breakpoint, indicated in the expression,\n       * That makes: start = 0, end = 2 (index of 'md' breakpoint)\n       *\n       * Parsing viewport.is('<md') we start at index 'xs' breakpoint, and end at\n       * 'sm' breakpoint, one before 'md'.\n       * Which makes: start = 0, end = 1\n       */\n      if (expression.operator === '<') {\n        start = 0\n        end = expression.orEqual ? ++pos : pos\n      }\n      /**\n       * Parsing viewport.is('>=sm') we interate from breakpoint 'sm' and end at the end\n       * of breakpoint list.\n       * That makes: start = 1, end = undefined\n       *\n       * Parsing viewport.is('>sm') we start at breakpoint 'md' and end at the end of\n       * breakpoint list.\n       * Which makes: start = 2, end = undefined\n       */\n      if (expression.operator === '>') {\n        start = expression.orEqual ? pos : ++pos\n        end = undefined\n      }\n\n      const acceptedBreakpoints = breakpointList.slice(start, end)\n\n      return this._isAnyActive(acceptedBreakpoints)\n    }\n  },\n}\n\nexport default Breakpoint\n"],"file":"breakpoint.js"}